% !TEX root = /home/benedict/Documents/Studium/Studienarbeit/Studienarbeit_Graphen_Metriken_Aehnlichkeit/Arbeit/T3101_Studienarbeit_GraphenMetriken_Weichselbaum_TINF2018.tex

\documentclass[a4paper,12pt,ngerman,chapterprefix=false,listof=totoc,bibliography=totoc]{scrreprt}

\usepackage[a4paper,left=2.5cm, right=2.5cm, top=2cm, bottom=2.5cm]{geometry}
\usepackage[ngerman, english]{babel}
\usepackage{blindtext}
\usepackage{helvet}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\renewcommand{\familydefault}{\sfdefault}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{index}
\usepackage{csquotes}
\usepackage[onehalfspacing]{setspace}
\usepackage{listings}
\usepackage{changepage}
\usepackage{acronym}
\usepackage{listings}
\usepackage{abstract}
\usepackage{scrhack}
\usepackage{booktabs}
\usepackage{pdflscape}
\usepackage{hyperref}
\usepackage{svg}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage[bottom]{footmisc}

% Biblatex includes
\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{literatur.bib}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

% Custom environments
\newenvironment{myitemize}{\begin{itemize}\itemsep -4pt}{\end{itemize}}
\newenvironment{myenumerate}{\begin{enumerate}\itemsep -4pt}{\end{enumerate}}
\newenvironment{myalphaenum}{\begin{enumerate}[label={\alph*)}]\itemsep -4pt}{\end{enumerate}}

% Custom commands
\newcommand{\absatz}{{\vspace{5mm}\newline}}
\newcommand{\zitat}[2]{
	\begin{quote}
		\textit{#1} \cite{#2}
	\end{quote}
}	
	
\newcommand{\geintrag}[2]{
	\textbf{#1}\begin{adjustwidth}{.5cm}{0cm}#2
	\end{adjustwidth}\vspace{3.5mm}
}
\newcommand{\singleenum}[2]{
	\begin{myenumerate}
		\setcounter{enumi}{#1}
		\item #2
	\end{myenumerate}
}

\newcommand{\specialcell}[2][l]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\newcommand{\metric}[3]{
	\textbf{#1}
	\vspace{1mm}
	\begin{adjustwidth}{.5cm}{0cm}
		\begin{tabular}{p{28mm} p{115mm}}
			Definition: & \specialcell{#2} \\
			Komplexität: & \specialcell{#3}
		\end{tabular}
	\end{adjustwidth}\hrulefill\\\vspace{2mm}
}

% Settings for bibliography from BibLaTeX
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\AfterTOCHead{\thispagestyle{empty}}

\begin{document}
\title{\Large{Untersuchung, Implementierungen und Bewertung von Graph-Metriken
}}
\author{Benedict Martin Weichselbaum}
\date{\today}
\selectlanguage{ngerman}
\begin{titlepage}
	\centering\hspace{8mm}
	\begin{figure}
		\centering
			\includegraphics[scale=1.3]{./Abbildungen/dhbwlogo.png}
	\end{figure}
	
	\vspace{5mm}	
	{\fontsize{26}{40}\selectfont
	Untersuchung, Implementierungen und Bewertung von Graph-Metriken
	}
	\\
	\vspace{2cm}
	\textbf{\Large{Studienarbeit}} \par
	\vspace{1cm}
	im Studiengang Informatik \par
	\vspace{0.3cm}
	an der Dualen Hochschule Baden-Württemberg Stuttgart, Campus Horb am Neckar \par
	\vspace{1.2cm}
	von \par
	\vspace{0.5cm}
	\textbf{\large{Benedict Weichselbaum}} \par
	\vspace{1.5cm}
	{\today}\par
	\vfill
	\begin{table}[ht]
		\hspace{1,5cm}
		\begin{tabular}{p{7cm}p{7cm}}
			\textbf{Bearbeitungszeitraum} & 28.09.2020 - 31.05.2021\\
			\textbf{Matrikelnummer, Kurs} & 6275457, TINF2018\\
			\textbf{Betreuer \& Gutachter} & Prof. Dr. ing. Olaf Herden\\
		\end{tabular}
	\end{table}
\end{titlepage}

\section*{Erklärung}
\thispagestyle{empty}
Ich versichere hiermit, dass ich meine Studienarbeit mit dem Thema \textit{Graphen: Metriken und Ähnlichkeit} selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.
\newline
Ich versichere zudem, dass die eingereichte elektronische Fassung mit der gedruckten Fassung übereinstimmt.\vspace{1.6cm}\newline
{Nürnberg, \today\vspace{1.2cm}\par\vspace{1.5cm}}
{\noindent\rule{6cm}{.4pt}\newline Benedict Martin Weichselbaum}

\selectlanguage{english}
\begin{abstract}
	
\end{abstract}

\selectlanguage{ngerman}
\setcounter{tocdepth}{3}

{\tableofcontents \thispagestyle{empty}}


\listoffigures\thispagestyle{plain}
\pagenumbering{Roman}
\setcounter{page}{1}

\listoftables\thispagestyle{plain}

\chapter*{Abkürzungsverzeichnis}
\addcontentsline{toc}{chapter}{Abkürzungsverzeichnis}
\begin{acronym}

\end{acronym}


\chapter{Einleitung}
\pagenumbering{arabic}
\setcounter{page}{1}
\section{Motivation für die Studienarbeit}{
Graphen sind einer der wichtigsten Datenstrukturen der Informatik. Warum kann man das sagen? In seinem Buch "`Algorithmische Graphentheorie"' nennt Volker Turau, Professor an der Universität Hamburg-Harburg, den Grund dafür: 
\zitat{Graphen sind die in der Informatik am häufigsten verwendete Abstraktion. Jedes System, welches aus diskreten Zuständen oder Objekten und Beziehungen zwischen diesen besteht, kann als Graph modelliert werden.}{turau_algorithmische_2004}
Diese netzartigen Strukturen können dabei die verschiedensten Konstrukte repräsentieren. Dazu zählen Straßennetze, Computernetzwerke, elektrische Schaltungen aber auch zum Beispiel chemische Moleküle. \cite{tittmann_graphentheorie_2019}

Um Graphen zu beschreiben und zu charakterisieren, haben sich über die Zeit zahlreiche Metriken, bzw. Eigenschaften für diese herausgebildet ("`graph properties"' \cite{lovasz_large_2012}). Das heißt, einem Graphen können gewisse Kennzahlen zugeordnet werden, die ihn auszeichnen. Auch diese Metriken sind, wie die Graphen selbst, meist praktisch anwendbar. Zum Beispiel in der Untersuchung von Netzwerken \cite{ellens_graph_2013}.

Diese Studienarbeit soll nun diese Metriken genauer untersuchen. Hierbei ist es zunächst wichtig die verschiedenste Metriken vorzustellen und zu erläutern. Dabei ist es auch wichtig herauszufinden, wie verbreitet diese Metriken sind und inwieweit die jeweiligen Kennzahlen zu bewerten sind. Des Weiteren soll auf Basis der Metriken auch der Begriff der Ähnlichkeit von Graphen aufgegriffen werden.

Neben einer theoretischen Betrachtung der Graphmetriken soll auch eine Implementierung stattfinden. Es ist dabei das Ziel, mithilfe von Graphdatenbanken die jeweiligen Metriken umzusetzen und diese miteinander zu Vergleichen.

In einem Weiteren Teil ist außerdem noch darauf einzugehen, welche Anwendung die gezeigten Metriken haben, um den praktischen Nutzen der Thematik aufzuzeigen.
}
\section{Fragestellungen}
{
Auf Basis dieser Motivation können nun auch die konkreten Fragestellungen formuliert werden, die diese Arbeit betrachten soll. Insgesamt sollen vier wissenschaftliche Fragen beantwortet werden.

\singleenum{0}{Welche Graph-Metriken gibt es und wie sind diese zu ermitteln und zu kategorisieren?}

Hierzu gehört, wie bereits erwähnt die Vorstellung der einzelnen Metriken, aber auch eine Kategorisierung in Rubriken, um Metriken besser voneinander abzugrenzen, da diverse Metriken höchst unterschiedliche Aussagen über einen Graphen treffen. Es wird auch darauf eingegangen welche Motivation hinter den jeweiligen Metriken steht.  Bei der Beantwortung dieser Frage soll außerdem auch darauf eingegangen werden, inwieweit die beschriebene Metrik in bestimmten Mathematikbibliotheken wie "`Sage Math"' oder "`Wolfram"' vorkommen.

\singleenum{1}{Wie sind die vorgestellten Metriken zu bewerten?}

In diesem Abschnitt soll es vor allem darum gehen, die vorgestellten Metriken dahingehend zu bewerten, wie "`schwer"' es ist, sie zu ermitteln. Außerdem soll bei der Bewertung auch auf die Verbreitung eingegangen werden. 

\singleenum{2}{Was beschreibt der Ähnlichkeitsbegriff bei Graphen?}

Basierend auf Graph-Metriken lässt sich auch ermitteln, ob zwei Graphen Ähnlichkeiten aufweißen \cite{wills_metrics_2019}. Auch auf diesen Aspekt soll die Arbeit bezug nehmen und dabei ein Anwendungs-Beispiel konstruieren.

\singleenum{3}{Wie können die vorgestellten Metriken in Graphdatenbanken verwendet werden, bzw. implementiert werden?}

Auf die theoretische Betrachtung der Graph-Metriken folgt dann ein praktischer Teil, der behandeln soll, wie sich die Metriken in bekannten Graphdatenbanken umsetzen lassen, bzw. umgesetzt wurden. Dabei ist es wichtig herauszufinden welche Graphkennzahlen bereits teil der Graphdatenbank-Lösungen sind, bzw. welche Metriken selbst umgesetzt werden müssen.

\singleenum{4}{Wie sind die jeweiligen Implementierungen zwischen und innerhalb der Graphdatenbanken zu bewerten?}

Folgend auf die Implementierung, ist es noch wichtig zu verstehen, wie diese Umsetzungen zu betrachten sind. Dabei wird vor allem ein Fokus auf das Thema Performance und Skalierung gelegt.

\singleenum{5}{Welche Anwendungen gibt es für Graph-Metriken und den Vergleich von Graphen (Ähnlichkeit)?}

Als letztes soll sich die Studienarbeit mit praktischen Beispielen beschäftigen. Es ist dabei wichtig zu verstehen, welchen konkreten Nutzen die gezeigten Kennzahlen für Graphen in modernen Anwendungsszenarien haben.
}
\chapter{Graph-Metriken}
{
Dieser erste Teil der Arbeit wird sich nun ausführlich mit einer weiten Reihe an Graph-Metriken beschäftigen. Hierbei sollen die ersten zwei Fragestellungen der Arbeit genau beantwortet werden. Zur jeweiligen Vorstellung einer Graph-Metrik sollen dabei die folgengen Punkte erläutert werden:
\begin{myitemize}
	\item Was drückt die Metrik aus (Definition)?
	\item Wie ist die Metrik im Bezug auf den Rechenaufwand zu bewerten?
	\item Inwieweit ist die Metrik verbreitet? Zum Beispiel in der Literatur oder in Mathematikbibliotheken.
	\item Was ist die konkrete Motivation für die Metrik, falls diese auszumachen ist?
\end{myitemize}
Es ist noch zu erwähnen, dass alle im folgenden vorgestellten Metriken über die einzelnen Sektionen der Arbeit in Kategorien eingeteilt sind.

Darüber hinaus ist noch eine grundsätzliche Notationen während der Arbeit zu klären: Ein \textbf{Graph G} ist ein Paar bestehend aus \textbf{Knoten V} und \textbf{Kanten E}.
\begin{align*}
	G = (V, E),\ wobei\ E \subseteq V \times V
\end{align*}
Für V können wir auch V(G) schreiben, für E auch E(G). \cite{diestel_graphentheorie_2000} V ist dabei Englisch und bedeutet "`Vertices"', E steht für "`Edges"'. Wenn es um die Datenstrukturen von Graphen geht, kommen im Rahmen dieser Arbeit hauptsächlich Adjazenzmatrizen und Adjazenzlisten zum Einsatz. Allerdings können bei Bedarf auch Inzidenzen (Beziehung zwischen Knoten und Kanten) im Graphen eine Rolle spielen, wie Inzidenzmatrizen und Inzidenzlisten. \cite{knebl_algorithmen_2019,diestel_graphentheorie_2000}
}
\section{Grundlegende Metriken}
{
Ein einem ersten Teil sollen grundlegende Graph-Kennzahlen vorgestellt werden. Diese beschreiben einen Graphen auf rudimentäre Art und Weise und zeigen die am einfachsten zu berechnenden Eigenschaften des Graphen.
}
\subsubsection*{Ordnung und Größe eines Graphen}
{
Die Frage danach, wie viele Knoten ein Graph hat lässt sich mit der \textbf{"`Ordnung"'} eines Graphen beantworten. Die "Ordnung" beschreibt dabei einfach die Anzahl der Elemente in der Menge V. Man schreibt: \(\vert V\vert\ oder\ \vert V(G)\vert\ oder\ auch\ \vert G\vert\). \cite{diestel_graphentheorie_2000} Diese Eigenschaft ist essentiell zur allgemeinen Beschreibung und z.B. graphischen Darstellung eines Graphen. Sie lässt sich dabei in sämtlichen mathematischen Bibliotheken finden, wie SageMath, Matlab und Wolfram \cite{sagemath_graph_2020,matlab_directed_2020,wolfram_graph_2020}. Die Komplexität zur Erfassung der Metrik gestaltet sich dabei äußerst einfach. Bei einer Adjazenzmatrix lässt sich die Anzahl der Knoten dadurch herausfinden, wie "`lang"' eine Dimension des zweidimensionalen Arrays bzw. der zweidimensionalen Liste. Dies kann man je nach Implementierung der jeweiligen Datenstruktur in einer Komplexität von \(O(n)\) oder \(O(1)\) herausfinden.

Eine weitere grundlegende Kennzahl von Graphen ist dessen \textbf{"`Größe"'}. Die Größe beschreibt dabei die Anzahl der Kanten, die im Graphen vorkommen, also die Anzahl der Elemente in der Menge E. Man schreibt analog zur Größe des Graphen: \(\vert E\vert\ oder\ \vert E(G)\vert\ oder\ auch\ \vert\vert G \vert\vert\). \cite{balakrishnan_schaums_1997,diestel_graphentheorie_2000} Auch diese Metrik ist weit verbreitet. So lässt sie sich in vielen Büchern zur Graphentheorie finden, aber auch in den genannten Mathematikbibliotheken \cite{sagemath_graph_2020,matlab_directed_2020,wolfram_graph_2020}. Die Anzahl der Kanten innerhalb eines Graphen herauszufinden, erweist sich nicht ganz so trivial wie das Herausfinden der Ordnung. Ist ein Graph nicht gerichtet, d.h. seine Kanten haben keine feste Richtung \cite{diestel_graphentheorie_2000} so ist seine Adjazenzmatrix symmetrisch. Man kann also zählen wie viele Einträge es innerhalb der Matrix auf der Hauptdiagonalen und einer der Hälften gibt. Das ergäbe immer \(\frac{1}{2}n^2\) Schritte, wenn \(n\) die Ordnung des Graphen ist. Die Komplexität beträge also \(O(n^2)\). Bei der Darstellung durch eine Inzidenzliste wäre das anders. Hier könnte einfach die Größe der Liste gesucht werden und man wüsste die Größe des Graphen. Die Komplexität wäre hier, wie schon erwähnt, je nach Implementierung \(O(n)\) oder \(O(1)\).
}
\subsubsection*{Der Grad eines Knotens}
{
Während die zwei ersten vorgestellten Metriken vor allem den Graphen als ganzes beschreiben, ist es auch noch wichtig zu wissen, was einen einzelnen Knoten auszeichnet, um einen Graphen besser zu beschreiben. Hierzu gibt es die grundlegende Metrik des \textbf{Grad} eines Knotens. Der Grad eines Knotens beschreibt die Anzahl der mit einem Knoten inzidenten Kanten \cite{diestel_graphentheorie_2000}. D.h. es drückt aus, wie viele Kanten mit einem Knoten verbunden sind. Man kann dies z.B. durch eine Funktion ausdrücken, die einen Knoten v auf eine natürliche Zahl abbildet: \(d(v)\).

Auf Basis dieser Metrik lässt sich auch andere verwandte Metriken ableiten. Hierzu gehört der \textbf{"`Minimalgrad"'} und der \textbf{"`Maximalgrad"'}. Der Minimalgrad ist der kleinste Knoten-Grad eines Graphen G: \(\delta (G):=min\{d(v)\ \vert\ v\ \in\ V(G)\}\). Parallel dazu ist der Maximalgrad der größte Knoten-Grad eines Graphen G: \(\Delta (G)\ :=\ max\{d(v)\ \vert\ v\ \in\ V(G)\}\). Darüber hinaus kann man noch den \textbf{"`Durchschnittsgrad"'} eines Graphen bestimmen. Dieser bildet den Durchschnitt aller Knotengrade ab: \(d(G):=\sum_{v\in V(G)}d(v)/\vert V\vert\). \cite{diestel_graphentheorie_2000}

Des Weiteren gibt es bei der Betrachtung eines gerichteten Graphen zusätzliche Abwandlungen der Metrik. Da hier die Kanten immer zu einem Knoten gerichtet sind unterscheidet man speziell zwischen dem \textbf{"`Eingangsgrad"'} und dem \textbf{"`Ausgangsgrad"'}. Der Eingangsgrad eines Knoten beschreibt dabei die Anzahl der Kanten, die auf einen Knoten "`zeigen"'. Der Ausgangsgrad zeigt wie viele Kanten von einem Knoten "`weggehen"'. \cite{balakrishnan_schaums_1997}

Auch der Grad eines Knotens und die meisten seiner verwandten Metriken sind weit verbreitet. So sind der allgemeine Grad, der Eingangsgrad, der Ausgangsgrad in allen drei betrachteten Mathematikbibliotheken vorhanden. SageMath unterstützt sogar nativ die Metrik "`Durchschnittsgrad"'. \cite{sagemath_graph_2020,matlab_directed_2020,wolfram_graph_2020}

Die Berechnung eines Grades über eine Adjazenzmatrix oder eine Adjazenzliste ist in linearer Zeit lösbar (\(O(n)\)). Bei der Adjazenzmatrix muss einfach nur die jeweilige Reihe des zugehörigen Knotens durchlaufen werden und gezählt werden, wie häufig ein Eintrag für eine Kante enthalten. Mit Hilfe der Adjazenzliste kann einfach die Größe der Liste als Grad genommen werden, die dem Knoten zugehörig ist.
}
\subsubsection*{Anzahl der Zusammenhangskomponenten}
{
Eine weitere Variante einen Graphen grundlegend zu beschreiben, besteht darin seine Zusammenhangskomponenten zu zählen. Hierfür ist es zunächst wichtig zu verstehen, was Zusammenhang bei Graphen bedeutet.

Ein Graph gilt dann als zusammenhängend, wenn gilt: \(\forall a, b(a\in V \land b\in V \land a\neq b \implies Weg\_existiert(a, b))\). Anschaulich bedeutet das, dass es zwischen zwei beliebigen Knoten immer einen Weg geben muss, der die beiden Knoten miteinander verbindet. Graphisch erscheint ein zusammenhängender Graph so, dass sich keine verschiedenen, klar voneinander trennbaren Komponenten erkennen lassen. Diese einzelnen Komponenten oder Partitionen eines nicht-zusammenhängenden Graphen werden "`Zusammenhangskomponenten"' genannt. Innerhalb der Zusammenhangskomponenten gilt natürlich wieder die Eigenschaft des Zusammenhangs. \cite{diestel_graphentheorie_2000}

Die Anzahl der Zusammenhangskomponenten gibt nun an, wie viele Komponenten innerhalb eines Graphen vorhanden sind. Die Metrik ist sowohl in MatLab als auch in SageMath vertreten \cite{sagemath_graph_2020,matlab_graph_2020}. Zur Ermittlung der Anzahl wird sich eines einfachen Algorithmus bedient, der die Tiefen- oder Breitensuche nutzt, die jeweils jeden Knoten als "`besucht"' markiert, den sie traversiert. Folgender Pseudocode beschreibt diesen Algorithmus:
\begin{lstlisting}
	Integer zaehleKomponenten (graph)
		int komponentenanzahl = 0
		for (knoten in graph)
			if (knoten ist nicht besucht)
				tiefen_oder_breitensuche(graph, knoten)
			komponentenanzahl++
		return komponentenanzahl
\end{lstlisting}
Da der Algorithmus von einem der Suchalgorithmen abhängig ist, bestimmt dieser die Komplexität zur Ermittlung der Kennzahl. Jeder Knoten wird genau einmal in dieser Prozedur besucht. Zudem wird über alle Knoten in der äußeren Zählschleife iteriert. Es ergibt sich dadurch eine Komplexität von \(O(\vert V\vert +\vert E\vert)\).
}
\section{Distanzmetriken}
{
Innerhalb der Graphentheorie gibt es den Begriff des Wegs. Ein Weg beschreibt dabei einen Graphen, der Knoten in einer Reihe hinterander Verbindet. Somit hat der Anfangs- und End-Knoten den Grad 1 und alle "`mittleren"' Knoten den Grad 2. Meist sucht man aber einen bestimmten Weg innerhalb eines bestehenden Graphen. Der Weg ist hier dann ein Teilgraph des ursprünglichen Graphen. Anschaulicher lässt sich ein Weg also als eine Folge von Kanten beschreiben, in der kein Knoten zweimal besucht wird. Die Länge eines Weges ist dabei die Anzahl der Kanten, die in einem Weg vorhanden sind. \cite{diestel_graphentheorie_2000} Auf Basis des Weges und seiner Längen-Eigenschaft lassen sich nun eine Reihe von Metriken definiert werden.
\subsubsection*{Abstand/Distanz}
{
Der "`Abstand"' ist eine Metrik, die auf Basis von zwei Knoten innerhalb eines Graphen definiert wird. Sie beschreibt die Länge des kürzesten Weges zwischen den zwei Knoten, von denen man den Abstand wissen will. Aufgeschrieben werden kann die Metrik mittels einer Funktion, die für den Graph G zwei Knoten x und y auf eine natürliche Zahl abbildet: \(d_G (x,y)\) \cite{diestel_graphentheorie_2000} Diese Metrik ist wichtig als Basis für andere Metriken. Wie die bisherigen Metriken ist auch diese in den jeweiligen Bibliotheken vertreten \cite{sagemath_graph_2020,matlab_shortest_2020,wolfram_graph_2020}. Zur Berechnung der Metrik kann auf verschiedene bekannte, graphtraversierende Algorithmen zurückgegriffen werden. Dazu zählen die Breitensuche, der Djikstra-Algorithmus oder der Bellman-Ford-Algorithmus \cite{sagemath_graph_2020}. Somit ist auch die Komplexität zum Herausfinden der Metrik gleich mit der der Algorithmen. So wäre bei einer Breitensuche eine Komplexität von \(O(\vert V\vert +\vert E\vert)\) zu erwarten, da jede Kante abgegangen wird. Der Djikstra-Algorithmus hingegen hat eine Komplexität von \(O(\vert V\vert ^2)\) \cite{jungnickel_graphs_2013}.
}
\subsubsection*{Extrenzität eines Knotens}
{
Mit Hilfe des Abstandes lässt sich nun u.a. die \textbf{"`Extrenzität"'}eines Knotens bestimmen. Die "`Extrenzität"' ist dabei der maximale Abstand den ein Knoten von einem anderen Knoten in einem Graphen G haben kann. Eine einfache formale Notierung für den Knoten x wäre: \(ecc(x, G)=max_{x,y}\{d_G(x,y)\}\), wobei x der gegebene Knoten ist. \cite{harary_graph_2001} Herauszufinden ist diese Kennzahl beispielsweise über den Djikstra-Algorithmus, der den kürzesten Abstand zu jedem anderen Knoten sucht und dann einfach der größte zu wählen ist. D.h. das die Metrik auch die Komplexität hat wie bei der Metrik "`Abstand"' erläutert wurde. Die Extrenzität eines Knotens ist anschließend noch für andere Metriken eine wichtige Basis und allgemein weit verbreitet in den genannten Bibliotheken \cite{sagemath_graph_2020,matlab_shortest_2020,wolfram_graph_2020}.
}
\subsubsection*{Durchmesser}
{
Wie schon erwähnt, ist es nun möglich auf Basis des Abstands weitere Metriken zu definieren. Hierzu zählt unter anderem der \textbf{"`Durchmesser"'} eines Graphen. Der Durchmesser beschreibt dabei den größten Abstand zweier Knoten im Graphen G. \cite{diestel_graphentheorie_2000} D.h. es ist der Abstand von allen Knoten zu allen Knoten zu berechnen und davon die größte Zahl auszuwählen. Formal notiert lässt sich die Metrik folgendermaßen beschreiben: \(Durchmesser(G)=max_{x,y}\{ d_G (x,y)\}\). Nimmt man zur Ermittlung der Abstände dabei den Djikstra-Algorithmus und wendet diesen dann jeweils auf jeden einzelnen Knoten an, kann eine Komplexität von \(O(\vert V\vert ^3)\) angenommen werden, um die Metrik zu extrahieren. Auch diese Metrik lässt sich z.B. in SageMath oder Wolfram finden. In Matlab kann der Durchmesser über die Distanzmatrix ermittelt werden, die Matlab erstellen kann. \cite{sagemath_graph_2020,matlab_shortest_2020,wolfram_graph_2020} Die Anwendung für diese Metrik kann z.B. sein, rein topologische Eigenschaften des Graphen herausfinden zu wollen. Allerdings kann auch in realen Problemen der Durchmesser als Metrik auftauchen. So ist z.B. der Abstand und damit der Durchmesser auch mit gewichteteten Kanten berechenbar. \cite{sagemath_graph_2020,gitta_durchmesser_2014} In einem Navigationssystem wäre der Durchmesser dann die längste fahrbare Strecke.
}
\subsubsection*{Radius}
{
Parallel zum Durchmesser eines Graphen kann man auch dessen \textbf{"`Radius"'} bestimmten. Hierfür wird die Metrik der Extrenzität wichtig und der Begriff der Zentralität. Eine Kante ist dann \textit{zentral} bzw. im Zentrum eines Graphen, wenn dessen Extrenzität minimal ist. Dies kann nur einen Knoten, aber auch mehrere Knoten betreffen. Die minimale Extrenzität in einem Graphen, die die Knoten des Zentrums haben, nennt man dann auch den \textbf{"`Radius"'} des Graphen. Geschrieben wird \(rad\ G = min_{x\in V(G)}max_{y\in V(G)}d_G(x,y)\). \cite{diestel_graphentheorie_2000} Der Radius lässt sich grundsätzlich auf die gleiche Weise herausfinden, wie der Durchmesser und hat dementsprechend die gleiche Komplexität. Des Weiteren ist diese Metrik auch weit verbreitet und lässt sich in allen untersuchten Bibliotheken finden \cite{sagemath_graph_2020,wolfram_graph_2020,matlab_shortest_2020}
}
}
\section{Kreis-basierte Metriken}
{
Ausgehend von einem Weg innerhalb eines Graphen können wir auch den Begriff des Kreises definieren. Ein Kreis ist dabei einfach ein Weg, der eine zyklische Eckenfolge hat. Sei \(x_i\) ein Knoten, so hat ein Kreis folgende typische Eckenfolge: \(x_0...x_{k-1},\ x_0\). \cite{diestel_graphentheorie_2000} Auch auf Basis solcher Kreise lassen sich verschiedene Graph-Metriken definieren.
}
\subsubsection*{Länge eines Kreises}
{
Ist ein solcher Kreis, wie vorhin beschrieben, gegeben, kann unter anderen an diesem seine Länge abgelesen werden. Die Länge beschreibt dabei die Anzahl der Kanten, die ein Kreis enthält. Ist erst einmal ein Kreis gegeben lässt sich die Länge leicht berechnen, denn die Länge eines Kreises ist gleich mit der Anzahl der Knoten innerhalb eines Kreises. Somit lässt sich die Länge in konstanter Zeit berechnen. \cite{diestel_graphentheorie_2000} Diese Metrik ist allerdings nicht direkt in referenzierten Mathematikbibliotheken vertreten, da grundsätzlich nur Graphen allgemein verarbeitet werden. Allerdings wäre es möglich, auf Basis des Wissens einen zyklischen Graphen zu erstellen und beispielsweise sich die Kantenanzahl zurückgeben zu lassen.
}
\subsubsection*{Taillenweite und Umfang}
{
Nimmt man die Länge eines Kreises als Basis, können weitere Kennzahlen für den gesamten Graphen ermittelt werden. Eine davon ist die "`Taillenweite"' des Graphen. Die "`Taillenweite"' ist so definiert, dass sie den Wert der Länge des kürzesten Kreises innerhalb des Graphen annimmt. Umgekehrt lässt sich auch der "`Umfang"' des Graphen bestimmen. Der Umfang ist dabei so groß wie die Länge des größtmöglichen Kreises innerhalb eines Graphen. Hat ein Graph keinen Kreis, so ist es nicht möglich für beide Kennzahlen einen Wert zu ermitteln. Allerdings haben diese dann einen festen Wert. So beträgt die "`Taillenweite"' in diesem Fall \(\infty\) und der Umfang null. \cite{diestel_graphentheorie_2000}

Um die Taillenweite und den Umfang eines Graphen herauszufinden, ist es grundsätzlich notwendig die jeweiligen Zyklen innerhalb des Graphen herauszufinden. Hierfür lässt sich unter anderem eine modifizierte Tiefensuche nutzen, die mittels Markierung der Knoten erkennt, ob sie bereits schon einmal bei einem Knoten war und infolgedessen einen Zyklus erkennt. Hierbei wird unterschieden, ob ein Knoten noch nicht bearbeitet wurde, in Bearbeitung ist oder bereits der Algorithmus auf ihm vollständig abgeschlossen wurde. Wird der Algorithmus auf einem Knoten aufgerufen, der sich noch in Bearbeitung befindet, ist ein Zyklus gefunden. Mit einer richtigen Ausgabe kann dieser dann auch benannt werden. Daraus folgt auch, dass die Ermittlung der Taillenweite und des Umfangs entspricht, denn nach der Tiefensuche, muss einfach der größte bzw. der kleinste Zyklus gewählt werden, um die Metriken zu ermitteln. Die Komplexität beträgt damit \(O(\vert V\vert +\vert E\vert)\). \cite{knebl_algorithmen_2019,vocking_taschenbuch_2008}

Zur Metrik "`Umfang"' lassen sich in den genannten Bibliotheken, außer bei Wolfram, keine direkten Implementierungen finden. Allerdings ist es möglich in SageMath und in Wolfram die "`Taillenweite"' direkt zu evaluieren. \cite{sagemath_graph_2020,wolfram_wolfram_2020}
}
\section{Zusammenhangsmetriken (Connectivity)}
{
Neben der Definition von Metriken auf Basis von Distanzen ist es auch möglich, Kennzahlen zu ermitteln, die den Zusammenhang eines Graphen betrachten. Hierfür ist es wichtig zu verstehen, wann ein Graph als zusammehängend gilt und was eine Zusammenhangskomponente bzw. Partition eines Graphen ist. Dies wurde bei der Metrik "`Anzahl der Zusammenhangskomponenten"' erläutert.
}
\subsubsection*{Dichte}
{
Bei der Vorstellung grundlegender Graphmetriken wurden u.a. die Größe und die Ordnung eines Graphen erklärt. Darauf aufbauend kann eine Kennzahl ermittelt werden, die aussagt, wie stark vernetzt ein Graph ist. Die "`Dichte"' eines Graphen gibt an, inwiefern der Graph so viele Kanten hat wie es ihm theoretisch möglich ist. Die "`Dichte"' setzt also tatsächliche Kantenanzahl (Größe) und die mögliche Kantenanzahl in ein Verhältnis. Die Metrik kann darauffolgend einen Wert zischen 0 und 1 annehmen. Ist der Wert 0 hat der Graph keine Kanten. Ist der Wert hingegen 1 so hat man einen vollständigen Graphen vor sich liegen. Möchte man die Dichte eines Graphen ermitteln ist es nötig die Größe des Graphen durch die potenzielle Größe zu teilen. Dies ist mit folgender Gleichung möglich: \(\frac{\vert E\vert}{\binom{\vert V\vert}{2}}\). Hat man statt einem ungerichteten Graphen einen gerichteten muss die Formel leicht abgewandelt werden, da für einen vollständigen Graphen nun doppelt so viele Kanten nötig sind: \(\frac{\vert E\vert}{2\binom{\vert V\vert}{2}}\). \cite{sagemath_graph_2020}

Zur Implementierung der Metrik ist es infolgedessen nur nötig die Größe und die Ordnung des Graphen herauszufinden. Die Komplexität zur Berechnung der "`Dichte"' ist deshalb gleich der Komplexität zur Berechnung von Größe und Ordnung addiert. Die Berechnung der "`Dichte"' selbst erfolgt in konstanter Zeit. Durch die Ableitung der Metrik aus zwei grundlegenden Kennzahlen ist die Berechnung auch problemlos möglich, ohne dass es eine explizite Implementierung in einer Bibliothek gibt. Allerdings bieten Wolfram und SageMath spezielle Funktionen für die "`Dichte"' eines Graphen. \cite{sagemath_graph_2020,wolfram_wolfram_2020,matlab_directed_2020}
}
\subsubsection*{Stärke}
{
Oft repräsentieren Graphen ein Netzwerk. Im Rahmen von Netzwerken wird unter anderem von deren "`Stärke"' gesprochen. Die "`Stärke"' gibt dabei das minimale Verhältnis zwischen entfernten Kanten und dadurch erstellter Zusammenhangskomponenten an. Es muss dabei allerdings die Anzahl der Zusammenhangskomponenten insgesamt erhöht werden. Ist die "`Stärke"' eines Netzwerks, bzw. eines Graphen, hoch, ist es u.a. schwieriger für einen Angreifer das Netzwerk stark zu beschädigen, greift dieser die Verbindungen, bzw. Kanten, des Netzwerks an. Zur Berechnung der Stärke \(\sigma(G)\) seien folgende Annahmen gegeben: Sei \(\Pi\) die Menge aller möglichen Partitionierungen der Knoten V und \(\partial\pi\) die Menge an Kanten, die entfernt werden müssten, um die Partitionierung \(\pi\) zu erreichen, gilt folgende Formel zur Errechnung der Stärke:
\[\sigma(G)=\min_{\pi\in\Pi}\frac{\vert\partial\pi\vert}{\vert\pi\vert -1}\]
Es wird also jede mögliche Partitionierung der Knoten V betrachtet und ermittelt welche Kanten man entfernen müsste, um diese Partitionierung der Knoten zu erhalten. Die Anzahl der Elemente in der jeweiligen Menge werden dann in ein Verhältnis gesetzt. Dabei wird eine Zusammenhangskomponenten aus \(\pi\) subtrahiert, da ein Graph immer zumindest aus einer Komponente besteht. Aus all diesen erstellten Verhältnissen ist nun das Minimum das Ergebnis. \cite{trubin_strenght_1993,cunningham_optimal_1985} Es kann auch anders gesagt werden, dass ein Graph bei dem die Entfernung weniger Kanten zu vergleichsweise vielen Zusammenhangskomponenten führt, ein sehr "`schwacher"' Graph ist. Umgekehrt ist es bei einem "`starken"' Graphen nicht möglich, selbst durch die Entfernung vieler Kanten (Zähler), eine vergleichsweise hohe Anzahl an Zusammenhangskomponenten (Nenner) zu erreichen.

Die Berechnung der "`Stärke"' und die Verbesserung der Komplexität des Algorithmus war Thema mehrerer wissenschaftlicher Arbeiten. Die beste erreichte Komplexität erzielte dabei V. A. Trubin mit einer Komplexität von \(O(\min(\sqrt{m},n^{2/3})mn\log(n^2/m+2))\). \(m\) ist hierbei die Anzahl an Kanten im Graphen, \(n\) die Anzahl an Knoten. \cite{trubin_strenght_1993}

In SageMath, Wolfram oder MatLab ist die "`Stärke"' von Graphen nicht implementiert. Darüber hinaus ist es auch möglich statt über die Entfernung von Kanten die Metrik über die Entfernung von Knoten definieren. In diesem Fall spricht man über die "`Härte"' oder "`Zähigkeit"' (engl. "`Toughness"') des Graphen. \cite{chvatal_tough_2006}
}
\subsubsection*{"`Vertex Connectivity"'/Zusammenhang}
{
Die Stärke eines Graphen ist eine nicht ganzzahlige Metrik zur Beschreibung des allgemeinen Zusammenhangs innerhalb eines Graphen. Wie bei der Stärke schon erwähnt, ist diese Metrik in den einschlägigen Bibliotheken nicht zu finden. Die nächsten zwei Metriken sind sowohl in SageMath als auch in Wolfram zu finden und beschreiben die stärke des Zusammenhangs des Graphen mittels einer ganzen Zahl \cite{sagemath_graph_2020,wolfram_graph_2020}

Die erste dieser Metriken ist die "`Vertex Connectivity"' oder "`Zusammenhang"'. Hierbei wird ein zusammenhängender oder auch nicht zusammenhängender Graph betrachtet und ermittelt wie viele Knoten aus dem Graphen mindestens entfernt werden müssen, sodass der Graph nicht mehr zusammehängend ist. \textit{k} entspricht dieser minimalen Anzahl an Knoten. Formal lässt sich sagen, dass ein Graph \textit{k-zusammenhängend} ist, wenn \(\vert G\vert > k\) und der Graph für jede mögliche Knotenmenge X mit der Mächtigkeit \(< k\) zusammenhängend bleibt, sobald man alle Knoten \(X\subseteq V\) aus V entfernt (\(G - X\)). Da ein Graph der \textit{3-zusammenhängend} ist auch \textit{4/5/...-zusammenhängend} ist, ist die absolute "`Vertex Connectivity"' bzw.  der "`Zusammenhang"' das \textit{k}, das für den Graph minimal ist. Der Zusammenhang ist dann 0, wenn der Graph von Anfang an nicht zusammenhängend ist oder der Graph nur aus einem Knoten besteht. \cite{diestel_graphentheorie_2000} Auch bei dieser Metrik gilt wie bei der Stärke, dass der Graph schwerer zu "`trennen"' ist, je höher die jeweilige Kennzahl ist. Daraus ist auch zu folgen, dass bei hohem Zusammenhang beispielweise ein Netzwerk weniger Anfällig für Angriffe ist.

Um den Zusammenhang eines Graphen algorithmisch herauszufinden, können zunächst zwei triviale Fälle abgedeckt werden. Ist ein Graph leer oder trivial (nur ein Knoten) ist der Zusammenhang, wie bereits erwähnt, 0. Ist hingegen der Graph vollständig, beträgt der Zusammenhang \(\vert V\vert\). Allerdings lässt sich auch ein allgemeiner Algorithmus definieren, der die "`Vertex Connectivity"' berechnet.  Für den Algorithmus wird eine zusätzliche Funktion benötigt. \(N(a,b)\) nimmt zwei Knoten entgegen. Eine Menge an Knoten, die bei Entfernung dafür sorgt, dass zwischen a und b kein Weg mehr existiert, wird "`Knoten-Separator"' genannt. N gibt nun die Kardinalität des minimalen "`Knoten-Separators"' von a und b zurück. Sind a und b direkt mit einer Kante verbunden, gibt es keinen "`Knoten-Separator"'. Sich diese Knotenpaare bei der Berechnung der "`Vertex Connectivity"' anzusehen, ist unnötig und muss nicht betrachtet werden. Schlussendlich ist nämlich die Kardinalität des kleinsten minimalen "`Knoten-Separators"' die gesuchte Kennzahl. Zur Berechnung gibt Shimon Even in seinem Buch "`Graph Algorithms"' folgenden Algorithmus an \cite{even_graph_2012}:
\begin{lstlisting}
	Vertex-Connectivity(V, E)
		Sortiere Knoten v_1, v_2, ..., v_|V| so, dass es von v_1 keine Kante zu irgendeinem v gibt
		gamma = unendlich
		i = 1
		while i <= gamma
			for each v, sodass v_i keine Kante zu irgendeinem v gibt
				gamma = min{gamma, N(v_i, v)}
		return gamma
\end{lstlisting}
Der gezeigte Algorithmus terminiert mit \(\gamma\) gleich dem Zusammenhang. In seinen Ausführungen erläutert Even zudem, dass der Algorithmus eine Zeitkomplexität von \(O(\vert V\vert^{1/2} \cdot \vert E\vert^2)\) aufweist.
}
\subsubsection*{"`Edge Connectivity"'}
{
Ähnlich zur "`Vertex Connectivity"' ist auch die "`Edge Connectivity"' ein ganzzahliges Zusammenhangsmaß für einen Graphen und ist auch ähnlich definiert. Wie die "`Vertex Connectivity"' ist diese in SageMath und Wolfram enthalten \cite{sagemath_graph_2020,wolfram_graph_2020}. Die "`Edge Connectivity"' ist nur definiert, wenn der Graph mindestens 2 Knoten hat. Hat ein Graph nur einen Knoten oder ist von Anfang an nicht zusammenhängend, so ist der auch sogenannte "`Kantenzusammenhang"' von G \(\lambda (G)\) gleich null. Ansonsten wird der Kantenzusammenhang so definiert, dass es die minimale Zahl an Kanten ist, die aus einem Graphen entnommen werden kann, sodass dieser nicht mehr zusammenhängend ist. Präziser kann es folgendermaßen definiert werden: Ein Graph hat einen Kantenzusammenhang von \(\lambda (G)\), wenn \(G - F\) für alle Kantenmengen \(F\subseteq E\) der Mächtigkeit \(< \lambda (G)\) zusammehängend ist. \cite{diestel_graphentheorie_2000} Die "`Vertex Connectivity"' bildet also das genau Pendant zur "`Vertex Connectivity"' und arbeitet komplett analog zu dieser Metrik.

%% Füge noch Algorithmus und Komplexität dessen ein!
}
\section{Zentralitätsmetriken}

\section{Arborizität}

\section{Chromatische Zahl und chromatischer Index}
{
Ein bekanntes Problem der Informatik ist das Färbeproblem. Es geht dabei darum einen Graphen so zu färben, sodass zwei benachbarte Knoten nicht die selbe Farbe haben. Anwendungen dafür kann man in vielen Problemen finden. Klassischerweise nimmt man das Beispiel der Karteneinfärbung bei der jedes Land ein Knoten ist und die Karte so eingefärbt werden soll, dass zwei benachbarte Länder nicht die gleiche Farbe haben. Allerdings lässt sich das Färbeproblem auch auf andere relevantere Probleme anwenden. Man kann z.B. so auch einen konfliktfreien Stundenplan erstellen oder andere ähnliche Konflikt-Probleme lösen. Die Eckenfärbung eines Graphen selbst ist eine Abbildung \(c: V\mapsto S\), wobei S die Menge an möglichen Färbungen ist. \cite{diestel_graphentheorie_2000,aigner_graphentheorie_2015} 
}
\subsubsection*{Chromatische Zahl}
{
Auf Basis der Färbeproblems können nun eine Reihe an Metriken definiert werden. Betrachtet man das Problem mithilfe der Abbildungsfunktion \(c\), so ist der Graph korrekt gefärbt, wenn gilt: \(\forall v, w (v\neq w \Rightarrow c(v)\neq c(w))\). Die "`chromatische Zahl"' beschreibt nun die Mächtigkeit der minimalen Menge \(S\) für die diese Bedingung zutrifft. Man bezeichnet die chromatische Zahl auch als \(X(G)\). Für einen leeren Graphen ist die chromatische Zahl 1. Liegt ein bipartiter Graph vor, so ist die chromatische Zahl offensichtlicherweise 2. \cite{diestel_graphentheorie_2000} Die chromatische Zahl kann sowohl von SageMath als auch von Wolfram berechnet werden \cite{sagemath_graph_2020-1,wolfram_wolfram_2020-1}

Das Herausfinden der chromatischen Zahl ist ein NP-vollständiges Problem und kann deshalb vermutlich auch nicht effizient berechnet werden. \cite{weisstein_chromatic_nodate,karp_reducibility_1996} So ist es möglich mittels eines Brute-Force-Algorithmus sämtliche Färbemöglichkeiten durchzuarbeiten und dann die Färbung herausnehmen, die gültig ist und die niedrigste Anzahl an Farben hat. Dieser Ansatz hätte eine exponentielle Laufzeit, die schon bei kleinen Graphen zu extrem hohen Rechenzeiten führen würde. Neben dieser naiven Variante werden u.a. auch heuristische Algorithmen genutzt, die versuchen die chromatische Zahl effizient zu approximieren. Ein bekannter Algorithmus hierfür ist folgendermaßen gegeben:
\begin{lstlisting}
	Chromatic-Number(G(V, E))
		vertices <- sortiere_nach_Grad_absteigend(V)
		highestColor <- 1
		for (vertex in vertices)
			color <- lowestPossibleColor(G, vertex)
			vertex.color = color
			highestColor <- Max{highestColor, color}
		return highestColor
\end{lstlisting}
Dieser Algorithmus hat allerdings den Nachteil, dass es nur eine Annäherung an die chromatische Zahl ist und nicht gesichert ist, dass das Ergebnis korrekt ist. Seine Strategie besteht darin, den Graphen mit möglichst wenig Farben zu färben, indem zuerst der Knoten gefärbt wird, der die meisten Nachbarn hat. 
}
\subsubsection*{Chromatischer Index}

\subsubsection*{Fraktionierte chromatische Zahl}

\section{Weitere Metriken}

\section{Übersicht der vorgestellten Graphmetriken}
{
Nachdem nun eine weite Reihe an Graph-Metriken vorgestellt wurden, sollen diese mit Hilfe einer Aufzählung zusammengefasst werden. Aufgelistet werden jeweils der Name, bzw die Bezeichnung, der Metrik, ihre Definition und die Komplexität zur Berechnung der Kennzahl. Bei der Definition wird dabei eine Mathematische oder eine wörtliche Beschreibung angegeben. Gegebenenfalls auch beides, falls es für das Verständnis förderlich ist.

\metric{Ordnung}{Anzahl der Knoten eines Graphen}{\(O(1)\ oder\ O(n)\)}
\metric{Größe}{Anzahl der Kanten eines Graphen}{Adjazenzmatrix/liste: \(O(n^2)\); Inzidenzmatrix/liste: \(O(1)\ oder\ O(n)\)}
}
\chapter{Ähnlichkeit von Graphen}

\chapter{Implementierung und Umsetzung der Metriken}

\section{Implementierung in verschiedenen Graphdatenbanken}

\section{Vergleich der Implementierungen}

\chapter{Graphmetriken und Ähnlichkeit in Anwendung}

\chapter{Fazit und Zusammenfassung}

\section{Zusammenfassung der Ergebnisse}

\section{Fazit}

\chapter*{Glossar}
\addcontentsline{toc}{chapter}{Glossar}
{
}
\printbibliography
\end{document}